// Globals and defaults
var settings = null;
var settingsFile = System.home("PD2Launcher.json");
var defaultSettings = {
	options: {
		playmode: "online",
		graphics: "3dfx",
		skiptobnet: true,
		sndbkg: false,
		closelauncher: false,
		ddrawmode: "borderless",
	},
	lootfilter: {
		"selectedAuthor": "Local",
		"selectedFilter": "default.filter",
		"filterDownloadUrl": "",
		"filterUrl": ""
	},
};


// UI elements, 
var modalBackground = $(#modal-background);
var optionsModal = $(#options-modal);
var lootFilterModal = $(#loot-filter-modal);
var playButton = $(#play-button);
var optionsForm = $(#options-form);
var lootFilterAuthors = $(#lootfilter-authors);
var lootFilterList = $(#lootfilter-list);
var lootFilterListHeader = $(#lootfilter-header);
var savedLootFilterListLabel = $(#saved);

var filterAuthors = { Local: { author: "Local", url: "", name: "Local Default and Custom Filters" } };
var filterAuthorFilters = { Local: {} };
var filterAuthorOrder = [];
var filtersUpdating = false;

var ddrawOptions = null;
var plugyExists = false;

var hasInternet = view.frame.hasInternet;


// Form startup
self.ready = async function() {
	// connect to debugger
	if (view.connectToInspector) {
		view.connectToInspector();
		stdout.println("\n\n\n--------------- STARTUP --------------\n\n\n");
	}

	// positioning the window in the middle of the screen:
	var (sx,sy,sw,sh) = view.screenBox(#workarea,#rectw); // getting screen/monitor size
	var (w, h) = (self.toPixels(750dip), self.toPixels(550dip));

	view.move(sx + (sw - w) / 2, sy + (sh - h) / 2, w, h);

	// Load saved options
	stdout.println("self.ready() :: loadSettingsFile()");
	loadSettingsFile();

	stdout.println("self.ready() :: loadDdrawSettingsFile()");
	loadDdrawSettingsFile();

	stdout.println("self.ready() :: setLoadedSettings()");
	setLoadedSettings();

	stdout.println("self.ready() :: checkForPlugy()");
	checkForPlugy();

	stdout.println("self.ready() :: getLootFilterList()");
	await getLootFilterList();

	stdout.println("self.ready() :: getLootFilterAuthorFilters()");
	await getLootFilterAuthorFilters();

	stdout.println("self.ready() :: loadLootFilterAuthors()");
	loadLootFilterAuthors();
}

async function getRemoteTexts(url) {
	try {
		var text = await view.request { url: url, output: #json };
		stdout.println("complete:", text);
	} catch (e) {
		stdout.println("got error:", e);
	}
}

// Handle ESC key to close
event keydown(e) {
	if (e.keyCode == Event.VK_ESCAPE) {
		if (modalBackground.attributes.hasClass("is-visible")) {
			closeModals();
		} else {
			view.close();
		}
	}
}

// Used by main program to update the state of the play button
self.finish_update = function () {
	delete playButton.attributes["disabled"];
	playButton.attributes.removeClass("disabled");
}

// Handle clicking url links
event click $(a[href ^= http]) {
	Sciter.launch(this.attributes["href"]);
	return true;
};

// Play button
event click $(#play-button) {
	// Play button animation
	playButton.attributes["disabled"] = true;
	playButton.attributes.addClass("disabled");

	// Send selected filter back to main to copy/download/whatever
	view.frame.setLootFilter(
		settings.lootfilter.filterOptions["selectedAuthor"],
		settings.lootfilter.filterOptions["selectedFilter"],
		settings.lootfilter.filterOptions["filterDownloadUrl"],
		settings.lootfilter.filterOptions["filterUrl"]
	);


	// Run PlugY or standard game
	var args = getLaunchArguments();
	switch (settings.options.playmode) {
		case "plugy":
		case "plugymodded":
			view.frame.playPlugy(args)
			break;

		case "online":
		default:
			view.frame.play(args);
	}

	if (settings.options.closelauncher) {
		closeModals();
		view.close();
	}
}

// Main function to add exceptions powershell script
event click $(#set-windows-sec-button) {
	view.frame.setPD2WindowsSettings();
}

// Main function to remove exceptions powershell script
event click $(#rem-windows-sec-button) {
	view.frame.remPD2WindowsSettings();
}

// Open plugy configuration
event click $(#edit-plugyini-button) {
	Sciter.launch("plugy.ini");
}

// Show options screen
event click $(#options-button) {
	modalBackground.attributes.addClass("is-visible");
	optionsModal.attributes.addClass("is-visible");
}

// Show loot filters screen if they're not still updating
// Add some better visual feedback to the form.  Cursor icon and/or button state/image
event click $(#loot-filters-button) {
	stdout.println(" >>> Lootfilter Options >>> Updating: " + filtersUpdating);
	if (!filtersUpdating) {
		openLootFiltersModal();
	}
}

// Close options screens when clicking outside of it
event click $(#modal-background) {
	closeModals();
}

// Handle close buttons on option screens
event click $(.modal-close) {
	closeModals();
}

// Handle input changes on the options screen
event change $(form) {
	// Convert form values so they are valid JSON types
	var s = this.value;
	for (var o in s) {
		if (s[o] === undefined || s[o] === "false")
			s[o] = false;

		if (s[o] === "true")
			s[o] = true;
	}
	settings.options = s;

	// Update some conditional settings and UI elements
	setDdrawmodeOptions();
	displayPlaymodeNotes();
	displayGraphicsNotes();
	displayDdrawModeOptions();
}

// Event listener to handle clicking a loot filter
event click $(.filter-item) {
	stdout.println(this.id + " -> " + this.value + " onClick");

	// Clear selection
	for (var i in $$(.filter-item)) {
		i.attributes.removeClass("filter-selected");
	}

	// Mark the currently selected filter
	stdout.println(this.id + " -> " + this.value + " onClick :: SELECTED");
	this.attributes.addClass("filter-selected");

	// Update settings with selected filter info
	var a = this.id.split("-")[2];
	settings.lootfilter = {
		selectedAuthor: a,
		selectedFilter: this.value,
		filterDownloadUrl: filterAuthorFilters[a][a + this.value].download_url,
		filterUrl: filterAuthorFilters[a][a + this.value].url
	}

	stdout.println(this.id + " -> " + this.value + " onClick :: settings.lootfilter = " + settings.lootfilter);
}

// Event listener for selecting a loot filter author
event click $(.author-item) {
	stdout.println("#author-listitem-" + this.value + " onClick");

	// Clear selection
	for (var i in $$(.author-item)) {
		i.attributes.removeClass("author-selected");
	}

	// Mark selected
	stdout.println("#author-listitem-" + this.value + " onClick :: SELECTED");
	this.attributes.addClass("author-selected");

	// Add author name and link above the filter list
	var filterAuthorInfo = filterAuthors[this.value];
	var url = filterAuthorInfo.url;
	if (this.value != "Local") {
		var urlParts = url.split("/");
		url = "https://github.com/" + urlParts.slice(4, 6).join("/");
	}
	lootFilterListHeader.clear();
	lootFilterListHeader.$append(
		<div>
			<a href="{url}">&#128712; - {filterAuthorInfo.name}</a>
		</div>
	);

	// Load the selected author's filters
	loadLootFilterAuthorFilters(this.value);
}

// Hide options if plugy isn't found
function checkForPlugy() {
	var plugyExists = System.scanFiles("plugy.exe");
	if (!plugyExists) {
		$(form).value.playmode = "online";
		$(#playmode-options-container).style.set({ display: "none" });
	}
}

// Read and load launcher settings
function loadSettingsFile() {
	stdout.println("loadSettingsFile() :: Begin");

	try {
		// Read and parse launcher options settings file
		var jsonData;
		var file = Stream.openFile(settingsFile, "r");
		if (file instanceof Stream) {
			jsonData = parseData(file);
			file.close();
		}

		// Check to make sure we got a proper object with settings
		if (typeof jsonData == "object") {
			if ("options" in jsonData && "lootfilter" in jsonData) {
				settings = jsonData;
			}
		}

		// Keep the loaded settings or fallback to the defaults
		settings = settings || defaultSettings;
	} catch (e) {
		view.msgbox(#alert, "Failed to load settings. Your options/loot filters will not save. \nThis is normally a permissions issue and running as admin once typically fixes it.", "Settings failed to load.");
	}

	stdout.println("loadSettingsFile() :: \n" + JSON.stringify(settings, null, 4));
	stdout.println("loadSettingsFile() :: End");
}

// Open and merge ddraw.ini settings with launcher settings
function loadDdrawSettingsFile() {
	ddrawOptions = view.frame.getDdrawOptions();
	settings.options = Object.assign({}, settings.options, ddrawOptions);
}

// Sets all of the options menu settings from the loaded settings
function setLoadedSettings() {
	// Need to convert false values from checkboxes to undefined
	var s = settings.options;
	for (var o in s) {		
		if (s[o] === false || s[o] === "false") {
			s[o] = undefined;
		}
	}

	// Set the initial values for the form, resets it update the elements and send event to handle changes
	optionsForm.value = s;
	optionsForm.reset();
	optionsForm.sendEvent("change");
}

// Write launcher options to json file
function writeSettingsFile() {
	// Remove ddraw options from launcher settings
	var s = settings;
	for (var k in ddrawOptions) {
		if (k in s.options)
			delete s.options[k];
	}

	try {
		var file = Stream.openFile(settingsFile, "w");
		file << JSON.stringify(s, null, 4) + "\n";
		file.close();
	}
	catch (e) {
		//view.msgbox(#alert, e);
		view.msgbox(#alert, "Failed to save settings. Your options/loot filters will not save. \nThis is normally a permissions issue and running as admin once typically fixes it.", "Settings failed to save.");
	}
}

// Write ddraw settings to ddraw.ini
function writeDdrawOptionsToIni() {
	view.frame.setDdrawOptions(settings.options);
}

// Hide or show playmode notes on the option screen depending on selected setting
function displayPlaymodeNotes() {
	var online = (settings.options.playmode == "online");
	var plugy = (settings.options.playmode == "plugy")
	var plugymodded = (settings.options.playmode == "plugymodded");

	$(#playmode-online-note).style.set({ display: (online ? "block" : "none") });
	$(#playmode-plugy-note).style.set({ display: (plugy ? "block" : "none") });
	$(#playmode-plugymodded-note).style.set({ display: (plugymodded ? "block" : "none") });
}

// Hide or show graphic mode notes on the option screen depending on selected setting
function displayGraphicsNotes() {
	var ddraw = (settings.graphics == "ddraw");

	$(#3dfx-note).style.set({ display: (ddraw ? "none" : "block") });
	$(#ddraw-note).style.set({ display: (ddraw ? "block" : "none") });	
}

// Update ddraw settings based on the selected mode
function setDdrawmodeOptions() {
	switch (settings.options.ddrawmode) {
		case "fullscreen":
			settings.options.fullscreen = true;
			settings.options.windowed = false;
			break;

		case "borderless":
			settings.options.fullscreen = true;
			settings.options.windowed = true;
			break;

		case "windowed":
			settings.options.fullscreen = false;
			settings.options.windowed = true;
			break;

		default:
	}

	// Hide or show windowed mode settings if selected
	$(#resolution).style.set { display: (settings.options.ddrawmode == "windowed") ? "block" : "none" };
}

// Hide or show ddraw options if selected
function displayDdrawModeOptions() {
	$(#ddraw-options-container).style.set({ display: (settings.options.graphics == "ddraw" ? "block" : "none") });
}

// Close options screens and save settings
function closeModals() {
	// Write launcher and ddraw settings to files
	writeDdrawOptionsToIni();
	writeSettingsFile();

	modalBackground.attributes.removeClass("is-visible");

	var modals = $$(.modal);
	for (var modal in modals) {
		modal.attributes.removeClass("is-visible");
	}
}

// Fetch online loot filters
async function getLootFilterList(suppressErrors = false) {
	stdout.println("getLootFilterList() :: Begin");

	if (!hasInternet) {
		filterAuthorOrder.push("Local");
		stdout.println("getLootFilterList() :: Offline, nothing to do");
		stdout.println("getLootFilterList() :: End");
		return;
	}

	filtersUpdating = true;		

	// data = (json, status) || false
	var data = await awaitRequest("https://raw.githubusercontent.com/Project-Diablo-2/LootFilters/main/filters.json");

	// Make sure the data is valid and add each author to the lists.
	if (data && data[1] == 200) {
		for (var d in data[0]) {
			if ("name" in d && "url" in d && "author" in d) {
				filterAuthors[d.author] = d;
				filterAuthorFilters[d.author] = {};
			}
		}
		if (data[0].length != filterAuthors.length - 1) {
			stdout.println("getLootFilterList() :: Filter list mismatch.  Expected " + data[0].length + ", received " + filterAuthors.length - 1);

			if (!suppressErrors) {
				view.msgbox(#alert, "The list of online filters contained invalid data or was missing.");
			}
		}			
	}

	// Sort the list of authors and keep Local on top. 		
	for (var a in filterAuthors) {
		if (a == "Local") {
			continue;
		}
		filterAuthorOrder.push(a);
	}

	// Case insensitive sort
	filterAuthorOrder.sort(function (a, b) {
		a = a[0].toLowerCase();
		b = b[0].toLowerCase();
		if (a == b) return 0;
		return a < b ? -1 : 1;
	});
	filterAuthorOrder.unshift("Local");
		
	stdout.println("getLootFilterList() :: Loot filter list loaded");
	stdout.println("getLootFilterList() :: End");
}

// Open loot filters screen
function openLootFiltersModal() {
	modalBackground.attributes.addClass("is-visible");
	lootFilterModal.attributes.addClass("is-visible");
}

// Add filter authors to the filter options screen
function loadLootFilterAuthors() {
	stdout.println("loadLootFilterAuthors() :: Start");

	for (var author in filterAuthorOrder) {
		stdout.println("loadLootFilterAuthors() :: " + author);		
		$(#authors-list).$append(
			<li id="author-listitem-{author}" value="{author}" class="author-item">{author}</li>
		);
	}

	// If the selected filter author from the settings exists, select it
	if (settings.lootfilter.selectedAuthor in filterAuthors) {
		$(#author-listitem-{settings.lootfilter.selectedAuthor}).sendEvent("click");
	}

	stdout.println("loadLootFilterAuthors() :: End");
}

// Add author's filters to the filter options screen
function loadLootFilterAuthorFilters(author) {
	stdout.println("loadLootFilterAuthorFilters(" + author + ") :: Start");

	// Clear list of filters
	$(#filters-list).clear();

	for (var item in filterAuthorFilters[author]) {
		var filter = filterAuthorFilters[author][item];

		stdout.println("loadLootFilterAuthorFilters(" + author + ") :: " + filter.name);

		// Add list item for each filter, mark one as selected if it exists
		var classes = (author == settings.lootfilter.selectedAuthor && filter.name == settings.lootfilter.selectedFilter) ? "filter-item filter-selected" : "filter-item";
		$(#filters-list).$append(
			<li id="filter-listitem-{author}-{filter.name}" value="{filter.name}" class="{classes}">{filter.name}</li>
		);
	}

	// Done updating filters
	filtersUpdating = false;
	stdout.println("loadLootFilterAuthorFilters(" + author + ") :: End");
}

// Gets list of filters for each author in the PD2 filters file.  Only does this once on startup.
async function getLootFilterAuthorFilters() {
	stdout.println("getLootFilterAuthorFilters() :: Begin");
	stdout.println("getLootFilterAuthorFilters() :: Fetching filters for " + filterAuthorFilters.length + " authors");

	// Get local filters
	var localFiles = view.frame.getLocalFiles();
	for (var f in localFiles) {
		f = f + "";
		if (f.indexOf(".filter") != -1) {
			filterAuthorFilters["Local"]["Local" + f] = {
				name: f,
				url: System.home("filters/local/") + f,
				download_url: System.home("filters/local/") + f
			};
		}
	}
	stdout.println("getLootFilterAuthorFilters() :: " + filterAuthorFilters["Local"].length + " filters loaded for <Local>");

	// Nothing to do if offline or only local filters are loaded
	if (!hasInternet || filterAuthors.length == 1) {
		filtersUpdating = false;

		stdout.println("getLootFilterAuthorFilters() :: only local filters -> End");
		return;
	}

	// Go through each author's filter list and store the info
	for (var author in filterAuthors) {
		var f = filterAuthors[author];
		if (f.author == "Local") {
			continue;
		}
		stdout.println("getLootFilterAuthorFilters() :: Fetching filters for " + f.author);
		var data = await awaitRequest(f.url);

		// Make sure we have a good return (status 200) and valid data
		if (data && data[1] == 200) {
			for (var d in data[0]) {
				if ("name" in d && "url" in d && "download_url" in d) {
					if (d.name.indexOf(".filter") != -1) {
						if ("name" in d && "url" in d && "download_url" in d) {
							filterAuthorFilters[f.author][f.author + d.name] = {
								name: d.name,
								url: d.url,
								download_url: d.download_url
							};
						}
					}
				}
			}
		}
		stdout.println("getLootFilterAuthorFilters() :: " + filterAuthorFilters[f.author].length + " filters loaded for <" + f.author + ">");
	}

	filtersUpdating = false;
	stdout.println("getLootFilterAuthorFilters() :: End");
}

// Throwing every async/await at this thing to make it actually run synchronous
async function awaitRequest(url, suppressError = false) {
	try {
		var text = await view.request { url: url, output: #json };
		return text;
	} catch (e) {
		var msg = "";
		switch (e.message.replace("\n", "")) {
			case "12029":
				msg = "No internet connection.";
				break;

			case "12157":
				msg = "TLS/SSL error.  Make sure TLS 1.2 is enabled in your Internet Options.";
				break;

			case "404":
				msg = "List of online filters not found.  Check that nothing is blocking your connection or try again later.";
				break;

			default:
				msg = e.message;
		}

		if (!suppressError) {
			view.msgbox(#error, msg, "Error - PD2Launcher");
		}
		stdout.println("checkRequestError() :: Error: " + e.name + " :: Message: " + e.message);
	}

	return false;
}

// Returns a string of command-line arguments based on the state of the launcher options
function getLaunchArguments() {
	var args = [];

	if (settings.options.graphics === '3dfx') {
		args.push('-3dfx');
	}

	switch (settings.options.playmode) {
		case 'plugymodded':
			args.push('-direct');
			args.push('-txt');

		case 'plugy':
			if (settings.options.sndbkg)
				args.push('-sndbkg');
			break;
			
		case 'online':
			if (settings.options.skiptobnet)
				args.push('-skiptobnet');

			if (settings.options.sndbkg)
				args.push('-sndbkg');
			
			break;
	}

	return args.join(" ");
}
