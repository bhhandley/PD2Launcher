// Settings and defaults
var debugLogFile = System.home("PD2Launcher_Debug.log");
var settings = null;
var settingsFile = System.home("PD2Launcher.json");
var defaultSettings = {
	options: {
		gamemode: "online",
		graphics: "3dfx",
		skiptobnet: true,
		sndbkg: false,
		closelauncher: false,
		ddrawmode: "borderless",
	},
	lootfilter: {
		selectedAuthor: "Local",
		selectedFilter: "default.filter",
		filterDownloadUrl: "",
		filterUrl: ""
	},
};
var ddrawOptions = null;
var plugyExists = false;


// UI elements, 
var body = $(body);
var modalBackground = $(#modal-background);
var optionsModal = $(#options-modal);
var lootFilterModal = $(#loot-filter-modal);
var playButton = $(#play-button);
var optionsForm = $(#options-form);
var lootFilterAuthors = $(#lootfilter-authors);
var lootFilterList = $(#lootfilter-list);
var lootFilterListHeader = $(#lootfilter-header);

// Item filter info
var filterAuthors = {};
var filterAuthorFilters = {};
var filterAuthorOrder = [];
var filtersUpdating = false;

// Internet status passed up from Main app
var hasInternet = view.frame.hasInternet;


// ------------ Form Startup ------------ //
self.ready = function () {
	// Init debug file
	printDebug("self.ready() :: Begin", true);

	// connect to debugger
	if (view.connectToInspector) {
		view.connectToInspector();		
	}

	// positioning the window in the middle of the screen:
	var (sx,sy,sw,sh) = view.screenBox(#workarea,#rectw); // getting screen/monitor size
	var (w, h) = (self.toPixels(750dip), self.toPixels(550dip));

	view.move(sx + (sw - w) / 2, sy + (sh - h) / 2, w, h);

	// Load saved options
	loadSettingsFile();
	loadDdrawSettingsFile();
	setLoadedSettings();
	checkForPlugy();
	refreshFilters();

	printDebug("self.ready() :: End");
}


// ------------ Event Handlers ------------ //

// Handle ESC key to close
event keydown(e) {
	if (e.keyCode == Event.VK_ESCAPE) {
		if (modalBackground.attributes.hasClass("is-visible")) {
			closeModals();
		} else {
			view.close();
		}
	}
}

// Used by main program to update the state of the play button
self.finish_update = function () {
	delete playButton.attributes["disabled"];
	playButton.attributes.removeClass("disabled");
}

// Handle clicking url links
event click $(a[href ^= http]) {
	Sciter.launch(this.attributes["href"]);
	return true;
};

// Play button
event click $(#play-button) {
	printDebug("#" + this.id + " :: Begin");

	// Play button animation
	playButton.attributes["disabled"] = true;
	playButton.attributes.addClass("disabled");

	printDebug(JSON.stringify(settings.lootfilter, null, 4));
	// Send selected filter back to main to copy/download/whatever
	view.frame.setLootFilter(
		settings.lootfilter.selectedAuthor,
		settings.lootfilter.selectedFilter,
		settings.lootfilter.filterDownloadUrl,
		settings.lootfilter.filterUrl
	);


	// Run PlugY or standard game
	var args = getLaunchArguments();
	printDebug("\tgamemode = '" + settings.options.gamemode + "' args = '" + args + "'");
	switch (settings.options.gamemode) {
		case "plugy":
		case "plugymodded":
			view.frame.playPlugy(args)
			break;

		case "online":
		default:
			view.frame.play(args);
	}

	if (settings.options.closelauncher) {
		closeModals();
		view.close();
	}

	printDebug("#" + this.id + " :: End");
}

// Main function to add exceptions powershell script
event click $(#set-windows-sec-button) {
	view.frame.setPD2WindowsSettings();
}

// Main function to remove exceptions powershell script
event click $(#rem-windows-sec-button) {
	view.frame.remPD2WindowsSettings();
}

// Open plugy configuration
event click $(#edit-plugyini-button) {
	Sciter.launch("plugy.ini");
}

// Show options screen
event click $(#options-button) {
	modalBackground.attributes.addClass("is-visible");
	optionsModal.attributes.addClass("is-visible");
}

// Show loot filters screen if they're not still updating
// Add some better visual feedback to the form.  Cursor icon and/or button state/image
event click $(#loot-filters-button) {
	if (!filtersUpdating) {
		openLootFiltersModal();
	}
}

// Close options screens when clicking outside of it
event click $(#modal-background) {
	closeModals();
}

// Handle close buttons on option screens
event click $(.modal-close) {
	closeModals();
}

// Handle input changes on the options screen
event change $(form) {
	// Convert form values so they are valid JSON types
	var s = this.value;
	for (var o in s) {
		if (s[o] === undefined || s[o] === "false")
			s[o] = false;

		if (s[o] === "true")
			s[o] = true;
	}
	settings.options = s;

	// Update some conditional settings and UI elements
	setDdrawmodeOptions();
	displayGamemodeNotes();
	displayGraphicsNotes();
	displayDdrawModeOptions();
}

// Event listener to handle clicking a loot filter
event click $(.filter-item) {
	printDebug("#" + this.id + ".onClick() -> " + this.value + " :: Begin");

	if (filtersUpdating) {
		printDebug("\tFilters updating - Exiting");
		printDebug("#" + this.id + " -> " + this.value + " onClick :: Filters updating - Exiting");
		return;
	}
	// Clear selection
	for (var i in $$(.filter-item)) {
		i.attributes.removeClass("filter-selected");
	}

	// Mark the currently selected filter
	printDebug("#" + this.id + " -> " + this.value + " onClick :: SELECTED");
	this.attributes.addClass("filter-selected");

	// Update settings with selected filter info
	var a = this.id.split("-")[2];
	settings.lootfilter = {
		selectedAuthor: a,
		selectedFilter: this.value,
		filterDownloadUrl: filterAuthorFilters[a][a + this.value].download_url,
		filterUrl: filterAuthorFilters[a][a + this.value].url
	}

	printDebug(JSON.stringify(settings.lootfilter, null, 4));
	printDebug("#" + this.id + ".onClick() -> " + this.value + " :: End");
}

// Event listener for selecting a loot filter author
event click $(.author-item) {
	printDebug("#" + this.id + ".onClick() -> " + this.value + ":: Begin");

	if (filtersUpdating) {
		printDebug("\t Filters updating - Exiting");
		printDebug("#" + this.id + ".onClick() -> " + this.value + ":: End");
		return;
	}
	// Clear selection
	for (var i in $$(.author-item)) {
		i.attributes.removeClass("author-selected");
	}

	// Mark selected
	printDebug("\t" + this.value + " :: SELECTED");
	this.attributes.addClass("author-selected");

	// Add author name and link above the filter list
	var filterAuthorInfo = filterAuthors[this.value];
	var url = filterAuthorInfo.url;
	if (this.value != "Local") {
		var urlParts = url.split("/");
		url = "https://github.com/" + urlParts.slice(4, 6).join("/");
	}
	lootFilterListHeader.clear();
	lootFilterListHeader.$append(
		<div>
			<a href="{url}">&#128712; - {filterAuthorInfo.name}</a>
		</div>
	);

	// Load the selected author's filters
	loadLootFilterAuthorFilters(this.value);

	printDebug("#" + this.id + ".onClick() -> " + this.value + ":: End");
}

// Event to handle refresh filters button
event click $(#refresh-filters-button) {
	printDebug("#" + this.id + ".onClick() :: Begin");
	
	refreshFilters();

	printDebug("#" + this.id + ".onClick() :: Begin");
}


// ------------ Functions ------------ //

// Downloads filter data and loads it
async function refreshFilters() {
	printDebug("refreshFilters() :: Begin");

	setFiltersUpdating(true);

	filterAuthors = { Local: { author: "Local", url: "", name: "Local Default and Custom Filters" } };
	filterAuthorFilters = { Local: {} };
	filterAuthorOrder = [];

	await getLootFilterList();
	await getLootFilterAuthorFilters();

	setFiltersUpdating(false);
	
	loadLootFilterAuthors();
	
	printDebug("refreshFilters() :: End");
}


// Hide options if plugy isn't found
function checkForPlugy() {
	var plugyExists = System.scanFiles("plugy.exe");
	if (!plugyExists) {
		$(form).value.gamemode = "online";
		$(#gamemode-options-container).style.set({ display: "none" });
	}
}

// Read and load launcher settings
function loadSettingsFile() {
	printDebug("loadSettingsFile() :: Begin");

	try {
		// Read and parse launcher options settings file
		var jsonData;
		var file = Stream.openFile(settingsFile, "r");
		if (file instanceof Stream) {
			jsonData = parseData(file);
			file.close();
		}

		// Check to make sure we got a proper object with settings
		if (typeof jsonData == "object") {
			if ("options" in jsonData && "lootfilter" in jsonData) {
				settings = jsonData;
			}
		}

		// Keep the loaded settings or fallback to the defaults
		settings = settings || defaultSettings;
	} catch (e) {
		view.msgbox(#alert, "Failed to load settings. Your options/loot filters will not save. \nThis is normally a permissions issue and running as admin once typically fixes it.", "Settings failed to load.");
	}

	printDebug("loadSettingsFile() :: \n" + JSON.stringify(settings, null, 4));
	printDebug("loadSettingsFile() :: End");
}

// Open and merge ddraw.ini settings with launcher settings
function loadDdrawSettingsFile() {
	printDebug("loadDdrawSetttingsFile() :: Begin");

	ddrawOptions = view.frame.getDdrawOptions();
	settings.options = Object.assign({}, settings.options, ddrawOptions);
	printDebug("ddrawOptions = " + JSON.stringify(ddrawOptions, null, 4));

	printDebug("loadDdrawSetttingsFile() :: End");
}

// Sets all of the options menu settings from the loaded settings
function setLoadedSettings() {
	printDebug("setLoadedSettings() :: Begin");

	// Need to convert false values from checkboxes to undefined
	var s = settings.options;
	for (var o in s) {		
		printDebug("\t" + o + " = " + s[o]);
		if (s[o] === false || s[o] === "false") {
			printDebug("\t\t" + s[o] + " -> undefined");
			s[o] = undefined;
		}
	}

	// Set the initial values for the form, resets it update the elements and send event to handle changes
	optionsForm.value = s;
	optionsForm.reset();
	optionsForm.sendEvent("change");

	printDebug("setLoadedSettings() :: End");
}

// Write launcher options to json file
function writeSettingsFile() {
	printDebug("writeSettingsFile() :: Begin");

	// Remove ddraw options from launcher settings
	var s = settings;
	for (var k in ddrawOptions) {
		if (k in s.options)
			delete s.options[k];
	}

	printDebug(JSON.stringify(s, null, 4));

	try {
		var file = Stream.openFile(settingsFile, "w");
		file << JSON.stringify(s, null, 4) + "\n";
		file.close();
	}
	catch (e) {
		//view.msgbox(#alert, e);
		view.msgbox(#alert, "Failed to save settings. Your options/loot filters will not save. \nThis is normally a permissions issue and running as admin once typically fixes it.", "Settings failed to save.");
	}

	printDebug("writeSettingsFile() :: End");
}

// Write ddraw settings to ddraw.ini
function writeDdrawOptionsToIni() {
	printDebug("writeDdrawOptionsToIni() :: Begin");
	printDebug(JSON.stringify(settings.options, null, 4));

	view.frame.setDdrawOptions(settings.options);

	printDebug("writeDdrawOptionsToIni() :: End");
}

// Hide or show gamemode notes on the option screen depending on selected setting
function displayGamemodeNotes() {
	var online = (settings.options.gamemode == "online");
	var plugy = (settings.options.gamemode == "plugy")
	var plugymodded = (settings.options.gamemode == "plugymodded");

	$(#gamemode-online-note).style.set({ display: (online ? "block" : "none") });
	$(#gamemode-plugy-note).style.set({ display: (plugy ? "block" : "none") });
	$(#gamemode-plugymodded-note).style.set({ display: (plugymodded ? "block" : "none") });
}

// Hide or show graphic mode notes on the option screen depending on selected setting
function displayGraphicsNotes() {
	var ddraw = (settings.options.graphics == "ddraw");

	$(#3dfx-note).style.set({ display: (ddraw ? "none" : "block") });
	$(#ddraw-note).style.set({ display: (ddraw ? "block" : "none") });	
}

// Update ddraw settings based on the selected mode
function setDdrawmodeOptions() {
	switch (settings.options.ddrawmode) {
		case "fullscreen":
			settings.options.fullscreen = true;
			settings.options.windowed = false;
			break;

		case "borderless":
			settings.options.fullscreen = true;
			settings.options.windowed = true;
			break;

		case "windowed":
			settings.options.fullscreen = false;
			settings.options.windowed = true;
			break;

		default:
	}

	// Hide or show windowed mode settings if selected
	$(#resolution).style.set { display: (settings.options.ddrawmode == "windowed") ? "block" : "none" };
}

// Hide or show ddraw options if selected
function displayDdrawModeOptions() {
	$(#ddraw-options-container).style.set({ display: (settings.options.graphics == "ddraw" ? "block" : "none") });
}

// Close options screens and save settings
function closeModals() {
	// Write launcher and ddraw settings to files
	writeDdrawOptionsToIni();
	writeSettingsFile();

	modalBackground.attributes.removeClass("is-visible");

	var modals = $$(.modal);
	for (var modal in modals) {
		modal.attributes.removeClass("is-visible");
	}
}

// Fetch online loot filters
async function getLootFilterList(suppressErrors = false) {
	printDebug("getLootFilterList() :: Begin");

	if (!hasInternet) {
		filterAuthorOrder.push("Local");
		printDebug("\tOffline. Local only");
		printDebug("getLootFilterList() :: End");
		return;
	}

	// data = (json, status) || false
	var data = await awaitRequest("https://raw.githubusercontent.com/Project-Diablo-2/LootFilters/main/filters.json");

	// Make sure the data is valid and add each author to the lists.
	if (data && data[1] == 200) {
		for (var d in data[0]) {
			if ("name" in d && "url" in d && "author" in d) {
				filterAuthors[d.author] = d;
				filterAuthorFilters[d.author] = {};
			}
		}
		if (data[0].length != filterAuthors.length - 1) {
			printDebug("\tFilter list mismatch.  Expected " + data[0].length + ", received " + filterAuthors.length - 1);

			if (!suppressErrors) {
				view.msgbox(#alert, "The list of online filters contained invalid data or was missing.");
			}
		}			
	}

	// Sort the list of authors and keep Local on top. 		
	for (var a in filterAuthors) {
		printDebug("\t" + a + " added");
		if (a == "Local") {
			continue;
		}
		filterAuthorOrder.push(a);
	}

	// Case insensitive sort
	filterAuthorOrder.sort(function (a, b) {
		a = a[0].toLowerCase();
		b = b[0].toLowerCase();
		if (a == b) return 0;
		return a < b ? -1 : 1;
	});
	filterAuthorOrder.unshift("Local");

	printDebug("getLootFilterList() :: End");
}

// Open loot filters screen
function openLootFiltersModal() {
	modalBackground.attributes.addClass("is-visible");
	lootFilterModal.attributes.addClass("is-visible");
}

// Add filter authors to the filter options screen
function loadLootFilterAuthors() {
	printDebug("loadLootFilterAuthors() :: Start");

	$(#authors-list).clear();
	$(#filters-list).clear();
	for (var author in filterAuthorOrder) {		
		printDebug("\tAdding " + author + " to options");
		$(#authors-list).$append(
			<li id="author-listitem-{author}" value="{author}" class="author-item">{author}</li>
		);		
	}

	// If the selected filter author from the settings exists, select it
	if (settings.lootfilter.selectedAuthor in filterAuthors) {
		$(#author-listitem-{settings.lootfilter.selectedAuthor}).sendEvent("click");
	}	

	printDebug("loadLootFilterAuthors() :: End");
}

// Add author's filters to the filter options screen
function loadLootFilterAuthorFilters(author) {
	printDebug("loadLootFilterAuthorFilters(" + author + ") :: Start");

	// Clear list of filters
	$(#filters-list).clear();

	for (var item in filterAuthorFilters[author]) {
		var filter = filterAuthorFilters[author][item];

		printDebug("\tAdding " + filter.name + " to options");

		// Add list item for each filter, mark one as selected if it exists
		var classes = (author == settings.lootfilter.selectedAuthor && filter.name == settings.lootfilter.selectedFilter) ? "filter-item filter-selected" : "filter-item";
		$(#filters-list).$append(
			<li id="filter-listitem-{author}-{filter.name}" value="{filter.name}" class="{classes}">{filter.name}</li>
		);
	}

	// Done updating filters
	printDebug("loadLootFilterAuthorFilters(" + author + ") :: End");
}

// Provides visual feedback when updating and sets global var for other checks
function setFiltersUpdating(updating) {
	printDebug("setFiltersUpdating(" + updating + ") :: Begin");

	filtersUpdating = updating;
	body.state.busy = updating;
	if (updating) {
		$(body).attributes.addClass("wait");
	} else {
		$(body).attributes.removeClass("wait");
	}

	printDebug("setFiltersUpdating(" + updating + ") :: End");
}

// Gets list of filters for each author in the PD2 filters file.  Only does this once on startup.
async function getLootFilterAuthorFilters() {
	printDebug("getLootFilterAuthorFilters() :: Begin");
	printDebug("\tFetching filters for " + filterAuthorFilters.length + " authors");

	// Get local filters
	var localFiles = view.frame.getLocalFiles();
	for (var f in localFiles) {
		f = f + "";
		if (f.indexOf(".filter") != -1) {
			filterAuthorFilters["Local"]["Local" + f] = {
				name: f,
				url: System.home("filters/local/") + f,
				download_url: System.home("filters/local/") + f
			};
		}
	}
	printDebug("\t" + filterAuthorFilters["Local"].length + " filters loaded for <Local>");

	// Nothing to do if offline or only local filters are loaded
	if (!hasInternet || filterAuthors.length == 1) {
		printDebug("\tNo internet or only local filters");
		printDebug("getLootFilterAuthorFilters() :: End");
		return;
	}

	// Go through each author's filter list and store the info
	for (var author in filterAuthors) {
		var f = filterAuthors[author];
		if (f.author == "Local") {
			continue;
		}
		printDebug("\tFetching filters for " + f.author);
		var data = await awaitRequest(f.url);

		// Make sure we have a good return (status 200) and valid data
		if (data && data[1] == 200) {
			for (var d in data[0]) {
				if ("name" in d && "url" in d && "download_url" in d) {
					if (d.name.indexOf(".filter") != -1) {
						if ("name" in d && "url" in d && "download_url" in d) {
							filterAuthorFilters[f.author][f.author + d.name] = {
								name: d.name,
								url: d.url,
								download_url: d.download_url
							};
						}
					}
				}
			}
		}
		printDebug("\t" + filterAuthorFilters[f.author].length + " filters loaded for " + f.author);
	}

	printDebug("getLootFilterAuthorFilters() :: End");
}

// Throwing every async/await at this thing to make it actually run synchronous
async function awaitRequest(url, suppressError = false) {
	printDebug("awaitRequest(" + url + ", " + suppressError + ") :: Begin");
	try {
		var response = await view.request { url: url, output: #json };
		printDebug("status = " + response[1] + "\ndata = " + JSON.stringify(response[0], null, 4));
		printDebug("awaitRequest(" + url + ", " + suppressError + ") :: End");
		return response;
	} catch (e) {
		var msg = "";
		switch (e.message.replace("\n", "")) {
			case "12029":
				msg = "No internet connection.";
				break;

			case "12157":
				msg = "TLS/SSL error.  Make sure TLS 1.2 is enabled in your Internet Options.";
				break;

			case "404":
				msg = "List of online filters not found.  Check that nothing is blocking your connection or try again later.";
				break;

			default:
				msg = e.message;
		}

		if (!suppressError) {
			view.msgbox(#error, msg, "Error - PD2Launcher");
		}
		printDebug("\tError: " + e.name + " :: Message: " + e.message);
	}
	printDebug("awaitRequest(" + url + ", " + suppressError + ") :: End");
	return false;
}

// Returns a string of command-line arguments based on the state of the launcher options
function getLaunchArguments() {
	var args = [];

	if (settings.options.graphics === '3dfx') {
		args.push('-3dfx');
	}

	switch (settings.options.gamemode) {
		case 'plugymodded':
			args.push('-direct');
			args.push('-txt');

		case 'plugy':
			if (settings.options.sndbkg)
				args.push('-sndbkg');
			break;
			
		case 'online':
			if (settings.options.skiptobnet)
				args.push('-skiptobnet');

			if (settings.options.sndbkg)
				args.push('-sndbkg');
			
			break;
	}

	return args.join(" ");
}

// Write to debug log
function printDebug(msg, overwrite = false) {
	try {
		var fileMode = (overwrite ? "w+" : "a+");

		var file = Stream.openFile(debugLogFile, fileMode);
		file << + msg + "\n";
		file.close();
	}
	catch (e) {
		//view.msgbox(#alert, e);
	}
}
